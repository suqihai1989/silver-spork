package com.sqh.tool.algorithm.tree.splay;

/**
 * 伸展树的基本思想是，当一个节点被访问后，它就要经过一系列AVL树的旋转被放到<br/>
 * 树根上。注意，如果一个节点很深，那么在其路径上就存在许多的节点也相对较深，通过<br/>
 * 重新构造可以使对所有这些节点的进一步访问所花费的时间变少。因此，如果节点过深，<br/>
 * 那么我们还要求重新构造应具有平衡这棵树（到某种程度）的作用。除在理论上给出好的<br/>
 * 时间界外，这种这种方法还可能有实际的效用，因为在许多应用中当一个节点被访问时，<br/>
 * 它就很可能不久再被访问到。研究表明，这种情况的发生比人们预料的要频繁得多。另外，<br/>
 * 伸展树还不要求保留高度或者平衡信息，因此它在某种程度上节省空间并简化代码。
 * @author Administrator
 *
 */
public class SplayTree {

}
